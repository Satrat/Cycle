require "sched"
require "Note.srp"
require "Node.srp"

e_minor = [4,6,7,9,11,0,2] #MIDI values for e minor scale
e_melodic = [1,3] #notes in e melodic that arent in e natural minor

class Chain:
	var start #start of melody, node instance
	var alter_prob #probability of inserting an embelishment between two melody notes
	var skip_prob #probability of skipping a note in the melody (currently unused)

    #transforms list of notes into a markov chain of nodes
    # represents the original, unaltered melody
	def init(arr, a_p,s_p):
		node = Node(arr[len(arr) - 1], [], [])
		for i = len(arr) - 2 to -1 by -1:
			note = arr[i]
			prev_node = Node(note, [node], [1.0])
			node = prev_node

		this.start = node  
		this.alter_prob = a_p
		this.skip_prob = s_p
		random_seed(time_get())

	def get_start():
		return this.start

	def print_chain():
		curr_node = this.start
		print "Node", curr_node
		while(curr_node.get_true_next() != nil):
			print "Node", curr_node.next
			curr_node = curr_node.get_true_next()

	# transforms original melody into probabilistic markov chain
	#this function should only be called once after the chain is initialized
	def setup_markov():
		curr_node = this.start

		#loop until the last note in the melody
		while(curr_node.get_true_next() != nil):
			next_node = curr_node.get_true_next()

			curr_note = curr_node.get_note()
			curr_pitch = curr_note.get_pitch()

			next_note = next_node.get_note()
			next_pitch = next_note.get_pitch()

			diff = abs(next_pitch - curr_pitch)

			mid_start = (next_note.get_start() + curr_note.get_start()) / 2
			mid_end = next_note.get_start()
			mid_vel = int(abs(next_note.get_vel() + curr_note.get_vel()) / 2)

			#add upper and lower neighbors
			if(diff == 0):
				pitch_class = curr_pitch % 12

				#half step above previous note, whole step below next (do and le)
				if(pitch_class == e_minor[0] or pitch_class == e_minor[5]):
					LN = Note(curr_pitch - 1, mid_vel, mid_start, mid_end)
					UN = Note(curr_pitch + 2, mid_vel, mid_start, mid_end)

				#whole step above previous note, whole step below next (la)
				#wrap around
				elif(pitch_class == e_melodic[0]):
					LN = Note(curr_pitch - 2, mid_vel, mid_start, mid_end)
					UN = Note(curr_pitch + 2, mid_vel, mid_start, mid_end)

				#whole step above previous note, half step below next(sol)
				#wrap around
				elif(pitch_class == e_minor[4]):
					LN = Note(curr_pitch - 2, mid_vel, mid_start, mid_end)
					UN = Note(curr_pitch + 1, mid_vel, mid_start, mid_end)

				#no danger of wrap around
				else:
					lp = pitch_class - 2

					# force into key
					if(lp % 12 not in e_minor and lp % 12 not in e_melodic):
					 	lp = lp + 1
					lp_offset = pitch_class - lp
					LN = Note(curr_pitch - lp_offset, mid_vel, mid_start, mid_end)

					up = pitch_class + 2

					#force into key
					if(up % 12 not in e_minor and up % 12 not in e_melodic):
					 	up = up - 1
					up_offset = up - pitch_class
					UN = Note(curr_pitch + up_offset, mid_vel, mid_start, mid_end)

				# added notes have 100% chance of proceeding to next note in the original melody
				UN_node = Node(UN, [next_node], [1.0])
				LN_node = Node(LN, [next_node], [1.0])

				# equal chance of hearing an upper or lower neighbor
				# chance of alteration dependant on alter_prob variable
				curr_node.next[next_node] = 1.0 - alter_prob
				curr_node.next[UN_node] = alter_prob / 2.
				curr_node.next[LN_node] = alter_prob / 2.

			#passing tone, longer distance
			elif(diff > 5):

				#find two notes in key to close the gap
				dist = (next_note.get_start() - curr_note.get_start())
				dist_1 = dist / 3.
				dist_2 = 2 * dist / 3.
				mid_start_1 = curr_note.get_start() + dist_1
				mid_start_2 = curr_note.get_start() + dist_2

				mid_note = int((next_pitch + curr_pitch) / 2)
				mid_note_1 = int((curr_pitch + mid_note) / 2)
				mid_note_2 = int((next_pitch + mid_note) / 2)

				#force into key
				if(mid_note_1 % 12 not in e_minor and mid_note_1 % 12 not in e_melodic):
					mid_note_1 = mid_note_1 + 1
				if(mid_note_2 % 12 not in e_minor and mid_note_2 % 12 not in e_melodic):
					mid_note_2 = mid_note_2 - 1

				passing_note_1 = Note(mid_note_1, mid_vel, mid_start_1, mid_start_2)
				passing_note_2 = Note(mid_note_2, mid_vel, mid_start_2, mid_end)

				passing_node_2 = Node(passing_note_2, [next_node], [1.0])
				passing_node_1 = Node(passing_note_1, [passing_node_2], [1.0])
				
				curr_node.next[passing_node_1] = alter_prob / 2.0

				#also probability of closing gap with just one note
				mid_note = int((next_pitch + curr_pitch) / 2)
				if(mid_note % 12 not in e_minor and mid_note % 12 not in e_melodic):
					mid_note = mid_note + 1

				passing_note = Note(mid_note, mid_vel, mid_start, mid_end)
				passing_node = Node(passing_note, [next_node], [1.0])
				curr_node.next[passing_node] = alter_prob / 2.0


				curr_node.next[next_node] = 1.0 - alter_prob


			#passing tones, short distance
			elif(diff > 3):

				#close the small gap with a single note
				mid_note = int((next_pitch + curr_pitch) / 2)
				if(mid_note % 12 not in e_minor and mid_note % 12 not in e_melodic):
					mid_note = mid_note + 1

				passing_note = Note(mid_note, mid_vel, mid_start, mid_end)
				passing_node = Node(passing_note, [next_node], [1.0])
				curr_node.next[passing_node] = alter_prob
				curr_node.next[next_node] = 1.0 - alter_prob

			curr_node = next_node





